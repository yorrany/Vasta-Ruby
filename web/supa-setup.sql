-- 1. Create Tables if they don't exist
CREATE TABLE IF NOT EXISTS public.tenants (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name text NOT NULL,
    slug text NOT NULL UNIQUE,
    status text DEFAULT 'active',
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS public.profiles (
    id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    tenant_id bigint REFERENCES public.tenants(id),
    email text,
    username text UNIQUE,
    slug text,
    display_name text,
    bio text,
    status text DEFAULT 'active',
    profile_image text,
    cover_image text,
    
    -- Appearance Settings (Ensuring these exist via ALTER below just in case)
    theme text DEFAULT 'adaptive', 
    link_style text DEFAULT 'glass', 
    typography text DEFAULT 'Inter',
    accent_color text DEFAULT '#6366F1',
    bg_color text, 
    
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Safely add columns if table already existed without them
DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'theme') THEN
        ALTER TABLE public.profiles ADD COLUMN theme text DEFAULT 'adaptive';
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'link_style') THEN
        ALTER TABLE public.profiles ADD COLUMN link_style text DEFAULT 'glass';
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'typography') THEN
        ALTER TABLE public.profiles ADD COLUMN typography text DEFAULT 'Inter';
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'accent_color') THEN
        ALTER TABLE public.profiles ADD COLUMN accent_color text DEFAULT '#6366F1';
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'bg_color') THEN
        ALTER TABLE public.profiles ADD COLUMN bg_color text;
    END IF;
    IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'profiles' AND column_name = 'username') THEN
        ALTER TABLE public.profiles ADD COLUMN username text UNIQUE;
    END IF;
END $$;

-- [NEW] Links Table
CREATE TABLE IF NOT EXISTS public.links (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    profile_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    title text NOT NULL,
    url text NOT NULL,
    icon text, -- Emoji or Lucide icon name
    display_order integer DEFAULT 0,
    is_active boolean DEFAULT true,
    clicks integer DEFAULT 0,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Enable RLS
ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.links ENABLE ROW LEVEL SECURITY;

-- Policies
-- Tenants
DROP POLICY IF EXISTS "Public read tenants" ON public.tenants;
CREATE POLICY "Public read tenants" ON public.tenants FOR SELECT USING (true);

-- Profiles
DROP POLICY IF EXISTS "Public read profiles" ON public.profiles;
CREATE POLICY "Public read profiles" ON public.profiles FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);
DROP POLICY IF EXISTS "Users can insert own profile" ON public.profiles;
CREATE POLICY "Users can insert own profile" ON public.profiles FOR INSERT WITH CHECK (auth.uid() = id);

-- Links
DROP POLICY IF EXISTS "Public read links" ON public.links;
CREATE POLICY "Public read links" ON public.links FOR SELECT USING (true);
DROP POLICY IF EXISTS "Users can manage own links" ON public.links;
CREATE POLICY "Users can manage own links" ON public.links FOR ALL USING (auth.uid() = profile_id);

-- [NEW] Products Table
CREATE TABLE IF NOT EXISTS public.products (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    profile_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    title text NOT NULL,
    description text,
    price numeric(10,2) DEFAULT 0.00,
    image_url text, -- For the product cover
    file_url text, -- For digital downloads
    status text DEFAULT 'active', -- active, draft, archived
    type text DEFAULT 'digital', -- digital, service, physical
    sales_count integer DEFAULT 0,
    created_at timestamptz DEFAULT now(),
    updated_at timestamptz DEFAULT now()
);

-- Enable RLS for Products
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;

-- Products Policies
DROP POLICY IF EXISTS "Public read products" ON public.products;
CREATE POLICY "Public read products" ON public.products FOR SELECT USING (status = 'active');

DROP POLICY IF EXISTS "Users can manage own products" ON public.products;
CREATE POLICY "Users can manage own products" ON public.products FOR ALL USING (auth.uid() = profile_id);

-- [NEW] Orders Table (Sales)
CREATE TABLE IF NOT EXISTS public.orders (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    profile_id uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE, -- Seller
    product_id bigint REFERENCES public.products(id) ON DELETE SET NULL,
    buyer_email text,
    amount numeric(10,2) NOT NULL,
    status text DEFAULT 'pending', -- pending, paid, refunded
    stripe_payment_intent_id text,
    created_at timestamptz DEFAULT now()
);

-- Enable RLS for Orders
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;

-- Orders Policies
DROP POLICY IF EXISTS "Users can view their sales" ON public.orders;
CREATE POLICY "Users can view their sales" ON public.orders FOR SELECT USING (auth.uid() = profile_id);

-- 2. Trigger Function to handle new user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger AS $func$
DECLARE
  new_tenant_id bigint;
  user_full_name text;
  user_slug text;
  user_email_prefix text;
BEGIN
  -- Extract info
  user_full_name := COALESCE(new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'name', split_part(new.email, '@', 1));
  user_email_prefix := split_part(new.email, '@', 1);
  -- Create a clean slug/username from email + random to ensure uniqueness
  user_slug := lower(regexp_replace(user_email_prefix, '[^a-zA-Z0-9]', '', 'g')) || floor(random() * 1000 + 1)::text;

  -- A. Create a default Tenant for the user
  INSERT INTO public.tenants (name, slug, status)
  VALUES (
    COALESCE(user_full_name, 'Minha Loja'),
    user_slug,
    'active'
  )
  RETURNING id INTO new_tenant_id;

  -- B. Create the Profile linked to the Tenant
  INSERT INTO public.profiles (
    id,
    tenant_id, 
    email, 
    username, -- Explicit username column
    slug, 
    display_name, 
    status
  )
  VALUES (
    new.id, -- Important: Link to Auth User ID
    new_tenant_id,
    new.email,
    user_slug, -- Default username is same as slug
    user_slug,
    user_full_name,
    'active'
  );

  RETURN new;
END;
$func$ LANGUAGE plpgsql SECURITY DEFINER;

-- 3. Attach the Trigger
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Storage Buckets (Optional - Requires enabling Storage Extension first, but commands are here)
-- insert into storage.buckets (id, name, public) values ('avatars', 'avatars', true) on conflict do nothing;
-- create policy "Avatar images are publicly accessible." on storage.objects for select using ( bucket_id = 'avatars' );
-- create policy "Anyone can upload an avatar." on storage.objects for insert with check ( bucket_id = 'avatars' ); 
